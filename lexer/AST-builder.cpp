#include "lexerpp.hpp"
#include <cstddef>
#include <cstdio>
#include <iostream>
#include <stack>
#include <string>
#include <vector>

class Lang {
public:
  std::vector<Token> tokens;
  int line_nr = 0;
  bool buffer_occupied = false;
  std::stack<Token> token_wait_area;
  std::stack<Token> inline_tokens;

  Lang(std::vector<Token> toks) {
    for (int i = toks.size(); i > 0; i--) {
      std::cout << "i is " << i << std::endl;
      inline_tokens.push(toks[i]);
    }
    std::cout << "done" << std::endl;
  }

  void __raiseError(std::string message) {
    throw std::invalid_argument("ERROR line " + std::to_string(line_nr) + ": " +
                                message);
  }

  // get the next token from our list of tokens
  // if theres a token in the wating stage (buffer), give that instead
  Token next_token() {
    if (!token_wait_area.empty()) {
      Token return_token = token_wait_area.top();
      token_wait_area.pop();
      return return_token;
    } else {
      std::cout << inline_tokens.empty() << std::endl;
      Token return_token = inline_tokens.top();
      std::cout << "made it to 41" << std::endl;
      inline_tokens.pop();
      return return_token;
    }
    std::cout << "leaving next_token()" << std::endl;
  };
  // sum aint right
  void print_inline_tokens() {
    std::cout << "printing inline tokens" << std::endl;
    while (!inline_tokens.empty()) {
      std::cout << inline_tokens.top().value;
      inline_tokens.pop();
    }
    std::cout << std::endl;
  }
};

// return number of tokens generated by lexer()
int count_tokens(Token *tokens_list) {
  int count = 0;
  while (tokens_list[count].type != END) {
    count++;
  }
  return count;
}

int main(int argc, char **argv) {

  std::string file_name = argv[1];

  std::ifstream fileObject{file_name};

  std::vector<Token> tokens = lexer(fileObject);

  Lang START(tokens);
  Token top = START.next_token();
  std::cout << "top token was " << top.value << std::endl;
  START.print_inline_tokens();

  return 0;
}
